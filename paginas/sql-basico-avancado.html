<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Masterclass: A Ciência dos Dados | DAnalise</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="page-styles.css">
    <style>
        .page-title-section.coleta-theme {
            background: var(--coleta-light);
            border-color: var(--coleta);
        }

        .page-title-section.coleta-theme::before {
            background: var(--coleta);
        }

        .content-section h2 {
            color: var(--coleta);
            border-color: var(--coleta-light);
        }

        .back-link:hover {
            color: var(--coleta);
        }

        .step-list li::before {
            background: var(--coleta);
            color: #111;
        }

        .step-list li:hover {
            border-color: var(--coleta);
        }

        .table-example th {
            background: var(--coleta);
            color: #111;
        }

        .formula-display {
            color: var(--coleta);
        }

        .nav-bottom a:hover {
            border-color: var(--coleta);
        }
    </style>
    <link rel="icon" href="../assets/logo-circle.png" type="image/png">
</head>

<body>
    <div id="subpage-theme-toggle" class="theme-toggle"
        style="position: absolute; top: 2rem; right: 2rem; z-index: 100;">
        <img id="theme-icon-img" src="../assets/moon-white.png" alt="Alternar Tema" style="width: 20px; height: 20px;">
    </div>
    <main class="content-page">
        <a href="../index.html#coleta" class="back-link">[<] Voltar para Modulo 2 - Coleta</a>

                <div class="page-title-section coleta-theme">
                    <h1>SQL Masterclass: Dominando a Linguagem de Dados</h1>
                    <p class="subtitle">Não aprenda apenas comandos. Entenda a arquitetura relacional, a ordem lógica de
                        execução e como otimizar consultas em escala de Big Data.</p>
                </div>

                <!-- CAPÍTULO 1: TEORIA DOS CONJUNTOS -->
                <section class="content-section">
                    <h2>1. Pensando em Conjuntos (Set Theory)</h2>
                    <p>O maior erro de quem vem do Excel para o SQL é continuar pensando em "linhas" e "células". SQL
                        não trata uma linha individualmente até o último momento. SQL trata <strong>Conjuntos
                            Matemáticos</strong>.</p>

                    <p>Imagine que você tem dois círculos (Diagrama de Venn):</p>
                    <ul>
                        <li><strong>Conjunto A:</strong> Clientes que compraram em 2024.</li>
                        <li><strong>Conjunto B:</strong> Clientes que moram em São Paulo.</li>
                    </ul>
                    <p>Quando fazemos uma query, estamos perguntando ao banco: "Qual é a interseção desses círculos?"
                        (INNER JOIN) ou "Quem está no círculo A mas não no B?" (LEFT JOIN com filtro NULL).</p>

                    <div class="curiosity-box">
                        <h4>💡 A Matemática Relacional</h4>
                        <p>O SQL foi baseada na "Álgebra Relacional" criada pelo Dr. Edgar Codd na IBM nos anos 70. Ele
                            provou matematicamente que qualquer pergunta sobre dados pode ser respondida usando apenas
                            operações de conjuntos (União, Diferença, Produto Cartesiano, Seleção e Projeção). Cada
                            <code>SELECT</code> que você escreve é uma equação matemática disfarçada de inglês.</p>
                    </div>
                </section>

                <!-- CAPÍTULO 2: A ORDEM DE EXECUÇÃO -->
                <section class="content-section">
                    <h2>2. A Ordem Secreta de Execução</h2>
                    <p>Você escreve: <code>SELECT ... FROM ... WHERE</code>. O computador lê em uma ordem completamente
                        diferente. Entender isso é a diferença entre um sênior e um júnior.</p>

                    <div class="example-box warning">
                        <h4>A Verdadeira Ordem que o Banco Executa:</h4>
                        <ol style="margin-left: 20px;">
                            <li><strong>FROM & JOIN:</strong> "Primeiro, pegue todas as tabelas e junte os dados
                                brutos." (Cria o dataset inicial no disco/memória).</li>
                            <li><strong>WHERE:</strong> "Agora filtre as linhas indesejadas IMEDIATAMENTE para
                                economizar memória." (Aqui sai o lixo).</li>
                            <li><strong>GROUP BY:</strong> "Agrupe o que sobrou em categorias."</li>
                            <li><strong>HAVING:</strong> "Filtre os grupos consolidados." (Ex: Só quero grupos com soma
                                > 1000).</li>
                            <li><strong>SELECT:</strong> "Só AGORA escolha quais colunas mostrar."</li>
                            <li><strong>ORDER BY:</strong> "Por fim, ordene o resultado para apresentar."</li>
                            <li><strong>LIMIT:</strong> "Corte para mostrar apenas N linhas."</li>
                        </ol>
                    </div>

                    <p><strong>Por que isso importa?</strong><br>
                        Você já tentou usar um apelido (alias) criado no SELECT dentro do WHERE e deu erro? Ex:
                        <code>SELECT valor * 2 AS dobro ... WHERE dobro > 10</code>. Isso falha porque o WHERE acontece
                        no passo 2, e o SELECT (que cria o apelido "dobro") só acontece no passo 5. Para o WHERE,
                        "dobro" ainda não existe no tempo. Lógica pura!</p>
                </section>

                <!-- CAPÍTULO 3: A CIÊNCIA DOS JOINS -->
                <section class="content-section">
                    <h2>3. A Ciência dos JOINs</h2>
                    <p>Um JOIN não é mágica. É um processo mecânico de comparação. Imagine duas listas de chamada de
                        alunos de turmas diferentes.</p>

                    <h3>Nested Loop Join (O Laço Aninhado)</h3>
                    <p>É assim que o banco pensa na forma mais bruta:</p>
                    <div class="formula-display">
                        Para cada linha da Tabela A (Clientes):
                        Pegue o ID do Cliente.
                        Percorra TODA a Tabela B (Pedidos) procurando esse ID.
                        Se achar, conecte e retorne.
                        Se não achar, descarte (no Inner Join).
                    </div>
                    <p>Isso explica por que JOINs são pesados. Se você tem 1.000 clientes e 1.000 pedidos, o banco pode
                        fazer teoricamente 1 milhão de comparações (1.000 x 1.000). É aqui que entram os
                        <strong>Índices</strong> (Indexes), que funcionam como o índice remissivo de um livro,
                        permitindo pular direto para a página certa sem ler o livro todo.</p>
                </section>

                <!-- CAPÍTULO 4: ESTUDOS DE CASO AVANÇADOS -->
                <section class="content-section">
                    <h2>4. Otimização de Queries (Performance Tuning)</h2>
                    <p>Em entrevistas para grandes empresas (Uber, iFood, Nubank), não basta a query funcionar. Ela tem
                        que ser rápida e barata.</p>

                    <div class="comparison-grid">
                        <div class="comparison-card">
                            <h4>❌ O Jeito Lento (SARGable Violation)</h4>
                            <div class="formula-display">
                                WHERE YEAR(data_venda) = 2023
                            </div>
                            <p><strong>O Problema:</strong> Ao aplicar uma função <code>YEAR()</code> na coluna, o banco
                                precisa calcular isso para CADA uma das 1 milhão de linhas antes de filtrar. Ele ignora
                                o índice.</p>
                        </div>
                        <div class="comparison-card">
                            <h4>✅ O Jeito Rápido (SARGable)</h4>
                            <div class="formula-display">
                                WHERE data_venda >= '2023-01-01'
                                AND data_venda <= '2023-12-31' </div>
                                    <p><strong>A Solução:</strong> Comparar a coluna bruta direto com um valor. O banco
                                        usa o índice e pula direto para os dados de 2023, ignorando o resto.</p>
                            </div>
                        </div>
                </section>

                <section class="content-section">
                    <h2>5. Desafio de Lógica SQL</h2>
                    <p>Problema: Encontre os usuários que compraram o item A e B, mas NÃO compraram o item C.</p>

                    <details class="spoiler-box">
                        <summary>Ver Raciocínio Lógico</summary>
                        <div class="spoiler-content">
                            <p>Este problema exige pensar em conjuntos. Não adianta tentar fazer tudo num WHERE simples.
                            </p>
                            <div class="formula-display">
                                SELECT user_id
                                FROM compras
                                GROUP BY user_id
                                HAVING
                                SUM(CASE WHEN item = 'A' THEN 1 ELSE 0 END) > 0 -- Tem A
                                AND
                                SUM(CASE WHEN item = 'B' THEN 1 ELSE 0 END) > 0 -- Tem B
                                AND
                                SUM(CASE WHEN item = 'C' THEN 1 ELSE 0 END) = 0; -- Não tem C
                            </div>
                            <p>Usamos a técnica de "Aggregation Filter". Agrupamos por usuário e sinalizamos (flag) a
                                presença de cada item.</p>
                        </div>
                    </details>
                </section>

                <nav class="nav-bottom">
                    <a href="../index.html#coleta">[<] Voltar ao Modulo</a>
                            <a href="modelagem-banco-dados.html">Proximo: Modelagem de Dados [>]</a>
                </nav>
    </main>
    <script src="subpage-script.js"></script>
</body>

</html>